=begin
#fastcomments

#No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

The version of the OpenAPI document: 0.0.0

Generated by: https://openapi-generator.tech
Generator version: 7.18.0-SNAPSHOT

=end

require 'date'
require 'time'

module FastCommentsClient
  class CommentLogData < ApiModelBase
    attr_accessor :clear_content

    attr_accessor :is_deleted_user

    attr_accessor :phrase

    attr_accessor :bad_word

    attr_accessor :word

    attr_accessor :locale

    attr_accessor :tenant_badge_id

    attr_accessor :badge_id

    attr_accessor :was_logged_in

    attr_accessor :found_user

    attr_accessor :verified

    attr_accessor :engine

    attr_accessor :engine_response

    attr_accessor :engine_tokens

    attr_accessor :trust_factor

    attr_accessor :rule

    attr_accessor :user_id

    attr_accessor :subscribers

    attr_accessor :notification_count

    attr_accessor :votes_before

    attr_accessor :votes_up_before

    attr_accessor :votes_down_before

    attr_accessor :votes_after

    attr_accessor :votes_up_after

    attr_accessor :votes_down_after

    attr_accessor :repeat_action

    attr_accessor :reason

    attr_accessor :other_data

    attr_accessor :spam_before

    attr_accessor :spam_after

    attr_accessor :permanent_flag

    attr_accessor :approved_before

    attr_accessor :approved_after

    attr_accessor :reviewed_before

    attr_accessor :reviewed_after

    attr_accessor :text_before

    attr_accessor :text_after

    attr_accessor :expire_before

    attr_accessor :expire_after

    attr_accessor :flag_count_before

    attr_accessor :trust_factor_before

    attr_accessor :trust_factor_after

    attr_accessor :referenced_comment_id

    class EnumAttributeValidator
      attr_reader :datatype
      attr_reader :allowable_values

      def initialize(datatype, allowable_values)
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        !value || allowable_values.include?(value)
      end
    end

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'clear_content' => :'clearContent',
        :'is_deleted_user' => :'isDeletedUser',
        :'phrase' => :'phrase',
        :'bad_word' => :'badWord',
        :'word' => :'word',
        :'locale' => :'locale',
        :'tenant_badge_id' => :'tenantBadgeId',
        :'badge_id' => :'badgeId',
        :'was_logged_in' => :'wasLoggedIn',
        :'found_user' => :'foundUser',
        :'verified' => :'verified',
        :'engine' => :'engine',
        :'engine_response' => :'engineResponse',
        :'engine_tokens' => :'engineTokens',
        :'trust_factor' => :'trustFactor',
        :'rule' => :'rule',
        :'user_id' => :'userId',
        :'subscribers' => :'subscribers',
        :'notification_count' => :'notificationCount',
        :'votes_before' => :'votesBefore',
        :'votes_up_before' => :'votesUpBefore',
        :'votes_down_before' => :'votesDownBefore',
        :'votes_after' => :'votesAfter',
        :'votes_up_after' => :'votesUpAfter',
        :'votes_down_after' => :'votesDownAfter',
        :'repeat_action' => :'repeatAction',
        :'reason' => :'reason',
        :'other_data' => :'otherData',
        :'spam_before' => :'spamBefore',
        :'spam_after' => :'spamAfter',
        :'permanent_flag' => :'permanentFlag',
        :'approved_before' => :'approvedBefore',
        :'approved_after' => :'approvedAfter',
        :'reviewed_before' => :'reviewedBefore',
        :'reviewed_after' => :'reviewedAfter',
        :'text_before' => :'textBefore',
        :'text_after' => :'textAfter',
        :'expire_before' => :'expireBefore',
        :'expire_after' => :'expireAfter',
        :'flag_count_before' => :'flagCountBefore',
        :'trust_factor_before' => :'trustFactorBefore',
        :'trust_factor_after' => :'trustFactorAfter',
        :'referenced_comment_id' => :'referencedCommentId'
      }
    end

    # Returns attribute mapping this model knows about
    def self.acceptable_attribute_map
      attribute_map
    end

    # Returns all the JSON keys this model knows about
    def self.acceptable_attributes
      acceptable_attribute_map.values
    end

    # Attribute type mapping.
    def self.openapi_types
      {
        :'clear_content' => :'Boolean',
        :'is_deleted_user' => :'Boolean',
        :'phrase' => :'String',
        :'bad_word' => :'String',
        :'word' => :'String',
        :'locale' => :'String',
        :'tenant_badge_id' => :'String',
        :'badge_id' => :'String',
        :'was_logged_in' => :'Boolean',
        :'found_user' => :'Boolean',
        :'verified' => :'Boolean',
        :'engine' => :'String',
        :'engine_response' => :'String',
        :'engine_tokens' => :'Float',
        :'trust_factor' => :'Float',
        :'rule' => :'SpamRule',
        :'user_id' => :'String',
        :'subscribers' => :'Float',
        :'notification_count' => :'Float',
        :'votes_before' => :'Float',
        :'votes_up_before' => :'Float',
        :'votes_down_before' => :'Float',
        :'votes_after' => :'Float',
        :'votes_up_after' => :'Float',
        :'votes_down_after' => :'Float',
        :'repeat_action' => :'RepeatCommentHandlingAction',
        :'reason' => :'RepeatCommentCheckIgnoredReason',
        :'other_data' => :'Object',
        :'spam_before' => :'Boolean',
        :'spam_after' => :'Boolean',
        :'permanent_flag' => :'String',
        :'approved_before' => :'Boolean',
        :'approved_after' => :'Boolean',
        :'reviewed_before' => :'Boolean',
        :'reviewed_after' => :'Boolean',
        :'text_before' => :'String',
        :'text_after' => :'String',
        :'expire_before' => :'Time',
        :'expire_after' => :'Time',
        :'flag_count_before' => :'Float',
        :'trust_factor_before' => :'Float',
        :'trust_factor_after' => :'Float',
        :'referenced_comment_id' => :'String'
      }
    end

    # List of attributes with nullable: true
    def self.openapi_nullable
      Set.new([
        :'votes_before',
        :'votes_up_before',
        :'votes_down_before',
        :'votes_after',
        :'votes_up_after',
        :'votes_down_after',
        :'other_data',
        :'expire_before',
        :'expire_after',
        :'flag_count_before',
      ])
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      if (!attributes.is_a?(Hash))
        fail ArgumentError, "The input argument (attributes) must be a hash in `FastCommentsClient::CommentLogData` initialize method"
      end

      # check to see if the attribute exists and convert string to symbol for hash key
      acceptable_attribute_map = self.class.acceptable_attribute_map
      attributes = attributes.each_with_object({}) { |(k, v), h|
        if (!acceptable_attribute_map.key?(k.to_sym))
          fail ArgumentError, "`#{k}` is not a valid attribute in `FastCommentsClient::CommentLogData`. Please check the name to make sure it's valid. List of attributes: " + acceptable_attribute_map.keys.inspect
        end
        h[k.to_sym] = v
      }

      if attributes.key?(:'clear_content')
        self.clear_content = attributes[:'clear_content']
      end

      if attributes.key?(:'is_deleted_user')
        self.is_deleted_user = attributes[:'is_deleted_user']
      end

      if attributes.key?(:'phrase')
        self.phrase = attributes[:'phrase']
      end

      if attributes.key?(:'bad_word')
        self.bad_word = attributes[:'bad_word']
      end

      if attributes.key?(:'word')
        self.word = attributes[:'word']
      end

      if attributes.key?(:'locale')
        self.locale = attributes[:'locale']
      end

      if attributes.key?(:'tenant_badge_id')
        self.tenant_badge_id = attributes[:'tenant_badge_id']
      end

      if attributes.key?(:'badge_id')
        self.badge_id = attributes[:'badge_id']
      end

      if attributes.key?(:'was_logged_in')
        self.was_logged_in = attributes[:'was_logged_in']
      end

      if attributes.key?(:'found_user')
        self.found_user = attributes[:'found_user']
      end

      if attributes.key?(:'verified')
        self.verified = attributes[:'verified']
      end

      if attributes.key?(:'engine')
        self.engine = attributes[:'engine']
      end

      if attributes.key?(:'engine_response')
        self.engine_response = attributes[:'engine_response']
      end

      if attributes.key?(:'engine_tokens')
        self.engine_tokens = attributes[:'engine_tokens']
      end

      if attributes.key?(:'trust_factor')
        self.trust_factor = attributes[:'trust_factor']
      end

      if attributes.key?(:'rule')
        self.rule = attributes[:'rule']
      end

      if attributes.key?(:'user_id')
        self.user_id = attributes[:'user_id']
      end

      if attributes.key?(:'subscribers')
        self.subscribers = attributes[:'subscribers']
      end

      if attributes.key?(:'notification_count')
        self.notification_count = attributes[:'notification_count']
      end

      if attributes.key?(:'votes_before')
        self.votes_before = attributes[:'votes_before']
      end

      if attributes.key?(:'votes_up_before')
        self.votes_up_before = attributes[:'votes_up_before']
      end

      if attributes.key?(:'votes_down_before')
        self.votes_down_before = attributes[:'votes_down_before']
      end

      if attributes.key?(:'votes_after')
        self.votes_after = attributes[:'votes_after']
      end

      if attributes.key?(:'votes_up_after')
        self.votes_up_after = attributes[:'votes_up_after']
      end

      if attributes.key?(:'votes_down_after')
        self.votes_down_after = attributes[:'votes_down_after']
      end

      if attributes.key?(:'repeat_action')
        self.repeat_action = attributes[:'repeat_action']
      end

      if attributes.key?(:'reason')
        self.reason = attributes[:'reason']
      end

      if attributes.key?(:'other_data')
        self.other_data = attributes[:'other_data']
      end

      if attributes.key?(:'spam_before')
        self.spam_before = attributes[:'spam_before']
      end

      if attributes.key?(:'spam_after')
        self.spam_after = attributes[:'spam_after']
      end

      if attributes.key?(:'permanent_flag')
        self.permanent_flag = attributes[:'permanent_flag']
      end

      if attributes.key?(:'approved_before')
        self.approved_before = attributes[:'approved_before']
      end

      if attributes.key?(:'approved_after')
        self.approved_after = attributes[:'approved_after']
      end

      if attributes.key?(:'reviewed_before')
        self.reviewed_before = attributes[:'reviewed_before']
      end

      if attributes.key?(:'reviewed_after')
        self.reviewed_after = attributes[:'reviewed_after']
      end

      if attributes.key?(:'text_before')
        self.text_before = attributes[:'text_before']
      end

      if attributes.key?(:'text_after')
        self.text_after = attributes[:'text_after']
      end

      if attributes.key?(:'expire_before')
        self.expire_before = attributes[:'expire_before']
      end

      if attributes.key?(:'expire_after')
        self.expire_after = attributes[:'expire_after']
      end

      if attributes.key?(:'flag_count_before')
        self.flag_count_before = attributes[:'flag_count_before']
      end

      if attributes.key?(:'trust_factor_before')
        self.trust_factor_before = attributes[:'trust_factor_before']
      end

      if attributes.key?(:'trust_factor_after')
        self.trust_factor_after = attributes[:'trust_factor_after']
      end

      if attributes.key?(:'referenced_comment_id')
        self.referenced_comment_id = attributes[:'referenced_comment_id']
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      warn '[DEPRECATED] the `list_invalid_properties` method is obsolete'
      invalid_properties = Array.new
      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      warn '[DEPRECATED] the `valid?` method is obsolete'
      permanent_flag_validator = EnumAttributeValidator.new('String', ["permanent"])
      return false unless permanent_flag_validator.valid?(@permanent_flag)
      true
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] permanent_flag Object to be assigned
    def permanent_flag=(permanent_flag)
      validator = EnumAttributeValidator.new('String', ["permanent"])
      unless validator.valid?(permanent_flag)
        fail ArgumentError, "invalid value for \"permanent_flag\", must be one of #{validator.allowable_values}."
      end
      @permanent_flag = permanent_flag
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          clear_content == o.clear_content &&
          is_deleted_user == o.is_deleted_user &&
          phrase == o.phrase &&
          bad_word == o.bad_word &&
          word == o.word &&
          locale == o.locale &&
          tenant_badge_id == o.tenant_badge_id &&
          badge_id == o.badge_id &&
          was_logged_in == o.was_logged_in &&
          found_user == o.found_user &&
          verified == o.verified &&
          engine == o.engine &&
          engine_response == o.engine_response &&
          engine_tokens == o.engine_tokens &&
          trust_factor == o.trust_factor &&
          rule == o.rule &&
          user_id == o.user_id &&
          subscribers == o.subscribers &&
          notification_count == o.notification_count &&
          votes_before == o.votes_before &&
          votes_up_before == o.votes_up_before &&
          votes_down_before == o.votes_down_before &&
          votes_after == o.votes_after &&
          votes_up_after == o.votes_up_after &&
          votes_down_after == o.votes_down_after &&
          repeat_action == o.repeat_action &&
          reason == o.reason &&
          other_data == o.other_data &&
          spam_before == o.spam_before &&
          spam_after == o.spam_after &&
          permanent_flag == o.permanent_flag &&
          approved_before == o.approved_before &&
          approved_after == o.approved_after &&
          reviewed_before == o.reviewed_before &&
          reviewed_after == o.reviewed_after &&
          text_before == o.text_before &&
          text_after == o.text_after &&
          expire_before == o.expire_before &&
          expire_after == o.expire_after &&
          flag_count_before == o.flag_count_before &&
          trust_factor_before == o.trust_factor_before &&
          trust_factor_after == o.trust_factor_after &&
          referenced_comment_id == o.referenced_comment_id
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [clear_content, is_deleted_user, phrase, bad_word, word, locale, tenant_badge_id, badge_id, was_logged_in, found_user, verified, engine, engine_response, engine_tokens, trust_factor, rule, user_id, subscribers, notification_count, votes_before, votes_up_before, votes_down_before, votes_after, votes_up_after, votes_down_after, repeat_action, reason, other_data, spam_before, spam_after, permanent_flag, approved_before, approved_after, reviewed_before, reviewed_after, text_before, text_after, expire_before, expire_after, flag_count_before, trust_factor_before, trust_factor_after, referenced_comment_id].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def self.build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      attributes = attributes.transform_keys(&:to_sym)
      transformed_hash = {}
      openapi_types.each_pair do |key, type|
        if attributes.key?(attribute_map[key]) && attributes[attribute_map[key]].nil?
          transformed_hash["#{key}"] = nil
        elsif type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[attribute_map[key]].is_a?(Array)
            transformed_hash["#{key}"] = attributes[attribute_map[key]].map { |v| _deserialize($1, v) }
          end
        elsif !attributes[attribute_map[key]].nil?
          transformed_hash["#{key}"] = _deserialize(type, attributes[attribute_map[key]])
        end
      end
      new(transformed_hash)
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        if value.nil?
          is_nullable = self.class.openapi_nullable.include?(attr)
          next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
        end

        hash[param] = _to_hash(value)
      end
      hash
    end

  end

end
